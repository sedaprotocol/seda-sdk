import {
	call_result_write,
	keccak256 as host_keccak256,
	secp256k1_verify,
} from "./bindings/seda_v1";
import { Bytes } from "./bytes";

/**
 * Verify whether a message was signed with the private key belonging to the public key.
 *
 * @category Crypto
 * @example
 * ```ts
	const message = Bytes.fromUtf8String("Hello, SEDA!");
	const signature = Bytes.fromHexString(
		"58376cc76f4d4959b0adf8070ecf0079db889915a75370f6e39a8451ba5be0c35f091fa4d2fda3ced5b6e6acd1dbb4a45f2c6a1e643622ee4cf8b802b373d38f",
	);
	const publicKey = Bytes.fromHexString(
		"02a2bebd272aa28e410cc74cef28e5ce74a9ffc94caf817ed9bd23b01ce2068c7b",
	);
	const isValidSignature = secp256k1Verify(message, signature, publicKey);

	Console.log(isValidSignature ? "valid" : "invalid"); // "valid"
 * ```
 * @param message the data that was signed
 * @param signature the signature generated by signing the message
 * @param publicKey the public key counterpart of the private key used to sign the message.
 */
export function secp256k1Verify(
	message: Bytes,
	signature: Bytes,
	publicKey: Bytes,
): bool {
	const messageBuffer = message.buffer;
	const messagePtr = changetype<usize>(messageBuffer);

	const signatureBuffer = signature.buffer;
	const signaturePtr = changetype<usize>(signatureBuffer);

	const publicKeyBuffer = publicKey.buffer;
	const publicKeyPtr = changetype<usize>(publicKeyBuffer);

	// Call secp256k1_verify and get the response length
	const responseLength = secp256k1_verify(
		messagePtr,
		messageBuffer.byteLength,
		signaturePtr,
		signatureBuffer.byteLength,
		publicKeyPtr,
		publicKeyBuffer.byteLength,
	);

	// Allocate an ArrayBuffer for the response
	const responseBuffer = new ArrayBuffer(responseLength);
	// Get the pointer to the response buffer
	const responseBufferPtr = changetype<usize>(responseBuffer);
	// Write the result to the allocated buffer
	call_result_write(responseBufferPtr, responseLength);
	// Convert the response buffer into a Uint8Array
	const responseArray = Uint8Array.wrap(responseBuffer);

	// Return true if the response is [1] (valid)
	return responseArray[0] === 1;
}

/**
 * Calculate the keccak256 hash of the input bytes.
 *
 * @category Crypto
 * @example
 * ```ts
	const message = Bytes.fromUtf8String("Hello, SEDA!");

	const hash = keccak256(message);

	Console.log(hash.toHexString()); // "5faa8e7e66ee9174b800ee6506e8af494f0e945cd99b03d8bc834ae446fe0e1c"
 * ```
 * @param message the data that needs to be hashed
 */
export function keccak256(message: Bytes): Bytes {
	const messageBuffer = message.buffer;
	const messagePtr = changetype<usize>(messageBuffer);

	const responseLength = host_keccak256(messagePtr, messageBuffer.byteLength);
	const responseBuffer = new ArrayBuffer(responseLength);
	const responseBufferPtr = changetype<usize>(responseBuffer);
	call_result_write(responseBufferPtr, responseLength);

	const responseArray = Uint8Array.wrap(responseBuffer);
	return Bytes.fromByteArray(responseArray);
}
