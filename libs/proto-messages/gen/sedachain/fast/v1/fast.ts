// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: sedachain/fast/v1/fast.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

/** Module parameters which can be changed through the authority. */
export interface Params {
}

/** FastClient contains information about a fast client. */
export interface FastClient {
  /**
   * The unique identifier of the fast client. Only used for internal purposes
   * to allow key rotation.
   */
  id: bigint;
  /** This address is allowed to update the config of the fast client. */
  ownerAddress: string;
  /**
   * This address is allowed to perform administrative actions on the fast
   * client.
   */
  adminAddress: string;
  /** The address of the fast client that's used to submit reports. */
  address: string;
  /**
   * The public key of the fast client used to verify signed requests and
   * identify the fast client.
   */
  publicKey: Uint8Array;
  /** The memo of the fast client. */
  memo: string;
  /** The balance of the fast client. */
  balance: string;
  /**
   * The user credits a fast client has used but not yet settled with the
   * balance.
   */
  usedCredits: string;
}

/** A user of a fast client. */
export interface FastUser {
  /** The identifier of the user, should be unique for a fast client. */
  userId: string;
  /** The amount of credits the user has. */
  credits: string;
}

/** A report of a user's usage of the fast. */
export interface FastUserReport {
  /** The identifier of the user. */
  userId: string;
  /**
   * The amount of credits the user has used. Includes the computation credits
   * AND the data proxy credits.
   */
  usedCredits: string;
  /** The reports of the data proxy queries made for the user. */
  dataProxyReports: DataProxyReport[];
  /** The number of queries made for the user. */
  queries: bigint;
}

/** A report of a user's usage of a data proxy. */
export interface DataProxyReport {
  /** The public key of the data proxy as a hex string. */
  dataProxyPubKey: string;
  /** The price of the data proxy in aseda when the query was made. */
  price: string;
  /** The amount of data proxy queries for the data proxy/price pair. */
  amount: bigint;
}

function createBaseParams(): Params {
  return {};
}

export const Params = {
  encode(_: Params, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Params {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Params {
    return {};
  },

  toJSON(_: Params): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Params>): Params {
    return Params.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Params>): Params {
    const message = createBaseParams();
    return message;
  },
};

function createBaseFastClient(): FastClient {
  return {
    id: 0n,
    ownerAddress: "",
    adminAddress: "",
    address: "",
    publicKey: new Uint8Array(0),
    memo: "",
    balance: "",
    usedCredits: "",
  };
}

export const FastClient = {
  encode(message: FastClient, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id.toString());
    }
    if (message.ownerAddress !== "") {
      writer.uint32(18).string(message.ownerAddress);
    }
    if (message.adminAddress !== "") {
      writer.uint32(26).string(message.adminAddress);
    }
    if (message.address !== "") {
      writer.uint32(34).string(message.address);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(42).bytes(message.publicKey);
    }
    if (message.memo !== "") {
      writer.uint32(50).string(message.memo);
    }
    if (message.balance !== "") {
      writer.uint32(58).string(message.balance);
    }
    if (message.usedCredits !== "") {
      writer.uint32(66).string(message.usedCredits);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FastClient {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFastClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.adminAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.address = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.balance = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.usedCredits = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FastClient {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      adminAddress: isSet(object.adminAddress) ? globalThis.String(object.adminAddress) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      balance: isSet(object.balance) ? globalThis.String(object.balance) : "",
      usedCredits: isSet(object.usedCredits) ? globalThis.String(object.usedCredits) : "",
    };
  },

  toJSON(message: FastClient): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.adminAddress !== "") {
      obj.adminAddress = message.adminAddress;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.balance !== "") {
      obj.balance = message.balance;
    }
    if (message.usedCredits !== "") {
      obj.usedCredits = message.usedCredits;
    }
    return obj;
  },

  create(base?: DeepPartial<FastClient>): FastClient {
    return FastClient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FastClient>): FastClient {
    const message = createBaseFastClient();
    message.id = object.id ?? 0n;
    message.ownerAddress = object.ownerAddress ?? "";
    message.adminAddress = object.adminAddress ?? "";
    message.address = object.address ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.memo = object.memo ?? "";
    message.balance = object.balance ?? "";
    message.usedCredits = object.usedCredits ?? "";
    return message;
  },
};

function createBaseFastUser(): FastUser {
  return { userId: "", credits: "" };
}

export const FastUser = {
  encode(message: FastUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.credits !== "") {
      writer.uint32(18).string(message.credits);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FastUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFastUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.credits = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FastUser {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      credits: isSet(object.credits) ? globalThis.String(object.credits) : "",
    };
  },

  toJSON(message: FastUser): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.credits !== "") {
      obj.credits = message.credits;
    }
    return obj;
  },

  create(base?: DeepPartial<FastUser>): FastUser {
    return FastUser.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FastUser>): FastUser {
    const message = createBaseFastUser();
    message.userId = object.userId ?? "";
    message.credits = object.credits ?? "";
    return message;
  },
};

function createBaseFastUserReport(): FastUserReport {
  return { userId: "", usedCredits: "", dataProxyReports: [], queries: 0n };
}

export const FastUserReport = {
  encode(message: FastUserReport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.usedCredits !== "") {
      writer.uint32(18).string(message.usedCredits);
    }
    for (const v of message.dataProxyReports) {
      DataProxyReport.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.queries !== 0n) {
      if (BigInt.asUintN(64, message.queries) !== message.queries) {
        throw new globalThis.Error("value provided for field message.queries of type uint64 too large");
      }
      writer.uint32(32).uint64(message.queries.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FastUserReport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFastUserReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usedCredits = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataProxyReports.push(DataProxyReport.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.queries = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FastUserReport {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      usedCredits: isSet(object.usedCredits) ? globalThis.String(object.usedCredits) : "",
      dataProxyReports: globalThis.Array.isArray(object?.dataProxyReports)
        ? object.dataProxyReports.map((e: any) => DataProxyReport.fromJSON(e))
        : [],
      queries: isSet(object.queries) ? BigInt(object.queries) : 0n,
    };
  },

  toJSON(message: FastUserReport): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.usedCredits !== "") {
      obj.usedCredits = message.usedCredits;
    }
    if (message.dataProxyReports?.length) {
      obj.dataProxyReports = message.dataProxyReports.map((e) => DataProxyReport.toJSON(e));
    }
    if (message.queries !== 0n) {
      obj.queries = message.queries.toString();
    }
    return obj;
  },

  create(base?: DeepPartial<FastUserReport>): FastUserReport {
    return FastUserReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FastUserReport>): FastUserReport {
    const message = createBaseFastUserReport();
    message.userId = object.userId ?? "";
    message.usedCredits = object.usedCredits ?? "";
    message.dataProxyReports = object.dataProxyReports?.map((e) => DataProxyReport.fromPartial(e)) || [];
    message.queries = object.queries ?? 0n;
    return message;
  },
};

function createBaseDataProxyReport(): DataProxyReport {
  return { dataProxyPubKey: "", price: "", amount: 0n };
}

export const DataProxyReport = {
  encode(message: DataProxyReport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dataProxyPubKey !== "") {
      writer.uint32(10).string(message.dataProxyPubKey);
    }
    if (message.price !== "") {
      writer.uint32(18).string(message.price);
    }
    if (message.amount !== 0n) {
      if (BigInt.asUintN(64, message.amount) !== message.amount) {
        throw new globalThis.Error("value provided for field message.amount of type uint64 too large");
      }
      writer.uint32(24).uint64(message.amount.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DataProxyReport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataProxyReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataProxyPubKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.price = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataProxyReport {
    return {
      dataProxyPubKey: isSet(object.dataProxyPubKey) ? globalThis.String(object.dataProxyPubKey) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      amount: isSet(object.amount) ? BigInt(object.amount) : 0n,
    };
  },

  toJSON(message: DataProxyReport): unknown {
    const obj: any = {};
    if (message.dataProxyPubKey !== "") {
      obj.dataProxyPubKey = message.dataProxyPubKey;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.amount !== 0n) {
      obj.amount = message.amount.toString();
    }
    return obj;
  },

  create(base?: DeepPartial<DataProxyReport>): DataProxyReport {
    return DataProxyReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataProxyReport>): DataProxyReport {
    const message = createBaseDataProxyReport();
    message.dataProxyPubKey = object.dataProxyPubKey ?? "";
    message.price = object.price ?? "";
    message.amount = object.amount ?? 0n;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToBigint(long: Long) {
  return BigInt(long.toString());
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
