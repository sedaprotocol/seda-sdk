// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: sedachain/fast/v1/tx.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { FastUserReport, Params } from "./fast";

/** SettleType defines the type of settle (withdraw or burn) */
export enum SettleType {
  /** SETTLE_TYPE_UNSPECIFIED - An unspecified settle type which will throw an error. */
  SETTLE_TYPE_UNSPECIFIED = 0,
  /** SETTLE_TYPE_WITHDRAW - Withdraw the credits to the admin address. */
  SETTLE_TYPE_WITHDRAW = 1,
  /** SETTLE_TYPE_BURN - Burn the credits. */
  SETTLE_TYPE_BURN = 2,
  UNRECOGNIZED = -1,
}

export function settleTypeFromJSON(object: any): SettleType {
  switch (object) {
    case 0:
    case "SETTLE_TYPE_UNSPECIFIED":
      return SettleType.SETTLE_TYPE_UNSPECIFIED;
    case 1:
    case "SETTLE_TYPE_WITHDRAW":
      return SettleType.SETTLE_TYPE_WITHDRAW;
    case 2:
    case "SETTLE_TYPE_BURN":
      return SettleType.SETTLE_TYPE_BURN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SettleType.UNRECOGNIZED;
  }
}

export function settleTypeToJSON(object: SettleType): string {
  switch (object) {
    case SettleType.SETTLE_TYPE_UNSPECIFIED:
      return "SETTLE_TYPE_UNSPECIFIED";
    case SettleType.SETTLE_TYPE_WITHDRAW:
      return "SETTLE_TYPE_WITHDRAW";
    case SettleType.SETTLE_TYPE_BURN:
      return "SETTLE_TYPE_BURN";
    case SettleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** All data required for a new fast client. */
export interface MsgRegisterFastClient {
  /** authority is the address that controls the fast module. */
  authority: string;
  /** the address that can edit the fast client. */
  ownerAddress: string;
  /**
   * The public key of the fast client used to verify signed requests as a hex
   * string.
   */
  publicKey: string;
  /**
   * admin_address defines the address that can perform administrative actions
   * on the fast client.
   */
  adminAddress: string;
  /** the address of the fast client that is allowed to submit reports. */
  address: string;
  /** memo defines an optional string which is not used by the protocol. */
  memo: string;
}

/**
 * MsgRegisterFastClientResponse is the response type for the
 * Msg/RegisterFastClient
 */
export interface MsgRegisterFastClientResponse {
}

/** Allows the owner to edit the fast client. */
export interface MsgEditFastClient {
  /** this should match the owner_address in the fast client */
  ownerAddress: string;
  /** the public key of the fast client as a hex string */
  fastClientPublicKey: string;
  /** [optional] the new admin address of the fast client */
  newAdminAddress: string;
  /** [optional] the new address of the fast client */
  newAddress: string;
  /** [optional] the new public key of the fast client as a hex string */
  newPublicKey: string;
  /** [optional] the new memo of the fast client */
  newMemo: string;
}

/**
 * MsgEditFastClientResponse is the response type for the Msg/EditFastClient RPC
 * method.
 */
export interface MsgEditFastClientResponse {
}

/**
 * Allows the owner to transfer the ownership of the fast client to a new
 * address.
 */
export interface MsgTransferOwnership {
  /** this should match the owner_address in the fast client */
  ownerAddress: string;
  /** the public key of the fast client as a hex string */
  fastClientPublicKey: string;
  /** the new owner address of the fast client */
  newOwnerAddress: string;
}

/**
 * MsgTransferOwnershipResponse is the response type for the
 * Msg/TransferOwnership RPC method.
 */
export interface MsgTransferOwnershipResponse {
}

/** Allows the new owner to accept the ownership of the fast client. */
export interface MsgAcceptOwnership {
  /** the address that is accepting the ownership */
  newOwnerAddress: string;
  /** the public key of the fast client as a hex string */
  fastClientPublicKey: string;
}

/**
 * MsgAcceptOwnershipResponse is the response type for the
 * Msg/AcceptOwnership RPC method.
 */
export interface MsgAcceptOwnershipResponse {
}

/** Allows the owner to cancel the ownership transfer of the fast client. */
export interface MsgCancelOwnershipTransfer {
  /** this should match the owner_address in the fast client */
  ownerAddress: string;
  /** the public key of the fast client as a hex string */
  fastClientPublicKey: string;
}

/**
 * MsgCancelOwnershipTransferResponse is the response type for the
 * Msg/CancelOwnershipTransfer RPC method.
 */
export interface MsgCancelOwnershipTransferResponse {
}

/** Allows the admin to add a user to the fast client. */
export interface MsgAddUser {
  /** this should match the admin_address in the fast client */
  adminAddress: string;
  /** the public key of the fast client as a hex string */
  fastClientPublicKey: string;
  /** the identifier of the user */
  userId: string;
  /** the amount of credits the user has initially */
  initialCredits: string;
}

/** MsgAddUserResponse is the response type for the Msg/AddUser RPC method. */
export interface MsgAddUserResponse {
}

/** Allows the admin to remove a user from the fast client. */
export interface MsgRemoveUser {
  /** this should match the admin_address in the fast client */
  adminAddress: string;
  /** the public key of the fast client as a hex string */
  fastClientPublicKey: string;
  /** the identifier of the user */
  userId: string;
}

/** MsgRemoveUserResponse is the response type for the Msg/RemoveUser RPC method. */
export interface MsgRemoveUserResponse {
}

/** Allows the admin to top up a user's credits. */
export interface MsgTopUpUser {
  /** the address that is toping up the user */
  sender: string;
  /** the public key of the fast client as a hex string */
  fastClientPublicKey: string;
  /** the identifier of the user */
  userId: string;
  /** the amount of credits to top up */
  amount: string;
}

/** MsgTopUpUserResponse is the response type for the Msg/TopUpUser RPC method. */
export interface MsgTopUpUserResponse {
}

/** Allows the admin to settle the credits of the fast client. */
export interface MsgSettleCredits {
  /** this should match the admin_address in the fast client */
  adminAddress: string;
  /** the public key of the fast client as a hex string */
  fastClientPublicKey: string;
  /** the type of settle */
  settleType: SettleType;
  /** the amount of credits to settle */
  amount: string;
}

/**
 * MsgSettleCreditsResponse is the response type for the Msg/SettleCredits RPC
 * method.
 */
export interface MsgSettleCreditsResponse {
  /** The amount of credits that were settled. */
  amount: string;
}

/** Allows the admin to expire the credits of a user. */
export interface MsgExpireUserCredits {
  /** this should match the admin_address in the fast client */
  adminAddress: string;
  /** the public key of the fast client as a hex string */
  fastClientPublicKey: string;
  /** the identifier of the user */
  userId: string;
  /** the amount of credits to expire */
  amount: string;
}

/**
 * MsgExpireUserCreditsResponse is the response type for the
 * Msg/ExpireUserCredits RPC method.
 */
export interface MsgExpireUserCreditsResponse {
}

/**
 * Allows the fast client to submit user reports to update credits and pay out
 * data proxy fees.
 */
export interface MsgSubmitReports {
  /** this should match the address in the fast client */
  address: string;
  /** the public key of the fast client */
  fastClientPublicKey: Uint8Array;
  /** the reports to process */
  reports: FastUserReport[];
}

/**
 * MsgSubmitReportsResponse is the response type for the Msg/SubmitReports RPC
 * method.
 */
export interface MsgSubmitReportsResponse {
}

/** The request message for the UpdateParams method. */
export interface MsgUpdateParams {
  /** authority is the address that controls the module. */
  authority: string;
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse is the response type for the Msg/UpdateParams RPC
 * method.
 */
export interface MsgUpdateParamsResponse {
}

function createBaseMsgRegisterFastClient(): MsgRegisterFastClient {
  return { authority: "", ownerAddress: "", publicKey: "", adminAddress: "", address: "", memo: "" };
}

export const MsgRegisterFastClient = {
  encode(message: MsgRegisterFastClient, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(18).string(message.ownerAddress);
    }
    if (message.publicKey !== "") {
      writer.uint32(26).string(message.publicKey);
    }
    if (message.adminAddress !== "") {
      writer.uint32(34).string(message.adminAddress);
    }
    if (message.address !== "") {
      writer.uint32(42).string(message.address);
    }
    if (message.memo !== "") {
      writer.uint32(50).string(message.memo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRegisterFastClient {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterFastClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.adminAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.address = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.memo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterFastClient {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      adminAddress: isSet(object.adminAddress) ? globalThis.String(object.adminAddress) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
    };
  },

  toJSON(message: MsgRegisterFastClient): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.adminAddress !== "") {
      obj.adminAddress = message.adminAddress;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRegisterFastClient>): MsgRegisterFastClient {
    return MsgRegisterFastClient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRegisterFastClient>): MsgRegisterFastClient {
    const message = createBaseMsgRegisterFastClient();
    message.authority = object.authority ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.publicKey = object.publicKey ?? "";
    message.adminAddress = object.adminAddress ?? "";
    message.address = object.address ?? "";
    message.memo = object.memo ?? "";
    return message;
  },
};

function createBaseMsgRegisterFastClientResponse(): MsgRegisterFastClientResponse {
  return {};
}

export const MsgRegisterFastClientResponse = {
  encode(_: MsgRegisterFastClientResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRegisterFastClientResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterFastClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRegisterFastClientResponse {
    return {};
  },

  toJSON(_: MsgRegisterFastClientResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRegisterFastClientResponse>): MsgRegisterFastClientResponse {
    return MsgRegisterFastClientResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRegisterFastClientResponse>): MsgRegisterFastClientResponse {
    const message = createBaseMsgRegisterFastClientResponse();
    return message;
  },
};

function createBaseMsgEditFastClient(): MsgEditFastClient {
  return {
    ownerAddress: "",
    fastClientPublicKey: "",
    newAdminAddress: "",
    newAddress: "",
    newPublicKey: "",
    newMemo: "",
  };
}

export const MsgEditFastClient = {
  encode(message: MsgEditFastClient, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }
    if (message.fastClientPublicKey !== "") {
      writer.uint32(18).string(message.fastClientPublicKey);
    }
    if (message.newAdminAddress !== "") {
      writer.uint32(26).string(message.newAdminAddress);
    }
    if (message.newAddress !== "") {
      writer.uint32(34).string(message.newAddress);
    }
    if (message.newPublicKey !== "") {
      writer.uint32(42).string(message.newPublicKey);
    }
    if (message.newMemo !== "") {
      writer.uint32(50).string(message.newMemo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditFastClient {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEditFastClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fastClientPublicKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.newAdminAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.newAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.newPublicKey = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.newMemo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgEditFastClient {
    return {
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      fastClientPublicKey: isSet(object.fastClientPublicKey) ? globalThis.String(object.fastClientPublicKey) : "",
      newAdminAddress: isSet(object.newAdminAddress) ? globalThis.String(object.newAdminAddress) : "",
      newAddress: isSet(object.newAddress) ? globalThis.String(object.newAddress) : "",
      newPublicKey: isSet(object.newPublicKey) ? globalThis.String(object.newPublicKey) : "",
      newMemo: isSet(object.newMemo) ? globalThis.String(object.newMemo) : "",
    };
  },

  toJSON(message: MsgEditFastClient): unknown {
    const obj: any = {};
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.fastClientPublicKey !== "") {
      obj.fastClientPublicKey = message.fastClientPublicKey;
    }
    if (message.newAdminAddress !== "") {
      obj.newAdminAddress = message.newAdminAddress;
    }
    if (message.newAddress !== "") {
      obj.newAddress = message.newAddress;
    }
    if (message.newPublicKey !== "") {
      obj.newPublicKey = message.newPublicKey;
    }
    if (message.newMemo !== "") {
      obj.newMemo = message.newMemo;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgEditFastClient>): MsgEditFastClient {
    return MsgEditFastClient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgEditFastClient>): MsgEditFastClient {
    const message = createBaseMsgEditFastClient();
    message.ownerAddress = object.ownerAddress ?? "";
    message.fastClientPublicKey = object.fastClientPublicKey ?? "";
    message.newAdminAddress = object.newAdminAddress ?? "";
    message.newAddress = object.newAddress ?? "";
    message.newPublicKey = object.newPublicKey ?? "";
    message.newMemo = object.newMemo ?? "";
    return message;
  },
};

function createBaseMsgEditFastClientResponse(): MsgEditFastClientResponse {
  return {};
}

export const MsgEditFastClientResponse = {
  encode(_: MsgEditFastClientResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditFastClientResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEditFastClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgEditFastClientResponse {
    return {};
  },

  toJSON(_: MsgEditFastClientResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgEditFastClientResponse>): MsgEditFastClientResponse {
    return MsgEditFastClientResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgEditFastClientResponse>): MsgEditFastClientResponse {
    const message = createBaseMsgEditFastClientResponse();
    return message;
  },
};

function createBaseMsgTransferOwnership(): MsgTransferOwnership {
  return { ownerAddress: "", fastClientPublicKey: "", newOwnerAddress: "" };
}

export const MsgTransferOwnership = {
  encode(message: MsgTransferOwnership, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }
    if (message.fastClientPublicKey !== "") {
      writer.uint32(18).string(message.fastClientPublicKey);
    }
    if (message.newOwnerAddress !== "") {
      writer.uint32(26).string(message.newOwnerAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTransferOwnership {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferOwnership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fastClientPublicKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.newOwnerAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTransferOwnership {
    return {
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      fastClientPublicKey: isSet(object.fastClientPublicKey) ? globalThis.String(object.fastClientPublicKey) : "",
      newOwnerAddress: isSet(object.newOwnerAddress) ? globalThis.String(object.newOwnerAddress) : "",
    };
  },

  toJSON(message: MsgTransferOwnership): unknown {
    const obj: any = {};
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.fastClientPublicKey !== "") {
      obj.fastClientPublicKey = message.fastClientPublicKey;
    }
    if (message.newOwnerAddress !== "") {
      obj.newOwnerAddress = message.newOwnerAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgTransferOwnership>): MsgTransferOwnership {
    return MsgTransferOwnership.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgTransferOwnership>): MsgTransferOwnership {
    const message = createBaseMsgTransferOwnership();
    message.ownerAddress = object.ownerAddress ?? "";
    message.fastClientPublicKey = object.fastClientPublicKey ?? "";
    message.newOwnerAddress = object.newOwnerAddress ?? "";
    return message;
  },
};

function createBaseMsgTransferOwnershipResponse(): MsgTransferOwnershipResponse {
  return {};
}

export const MsgTransferOwnershipResponse = {
  encode(_: MsgTransferOwnershipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTransferOwnershipResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferOwnershipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTransferOwnershipResponse {
    return {};
  },

  toJSON(_: MsgTransferOwnershipResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTransferOwnershipResponse>): MsgTransferOwnershipResponse {
    return MsgTransferOwnershipResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgTransferOwnershipResponse>): MsgTransferOwnershipResponse {
    const message = createBaseMsgTransferOwnershipResponse();
    return message;
  },
};

function createBaseMsgAcceptOwnership(): MsgAcceptOwnership {
  return { newOwnerAddress: "", fastClientPublicKey: "" };
}

export const MsgAcceptOwnership = {
  encode(message: MsgAcceptOwnership, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.newOwnerAddress !== "") {
      writer.uint32(10).string(message.newOwnerAddress);
    }
    if (message.fastClientPublicKey !== "") {
      writer.uint32(18).string(message.fastClientPublicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAcceptOwnership {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAcceptOwnership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.newOwnerAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fastClientPublicKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAcceptOwnership {
    return {
      newOwnerAddress: isSet(object.newOwnerAddress) ? globalThis.String(object.newOwnerAddress) : "",
      fastClientPublicKey: isSet(object.fastClientPublicKey) ? globalThis.String(object.fastClientPublicKey) : "",
    };
  },

  toJSON(message: MsgAcceptOwnership): unknown {
    const obj: any = {};
    if (message.newOwnerAddress !== "") {
      obj.newOwnerAddress = message.newOwnerAddress;
    }
    if (message.fastClientPublicKey !== "") {
      obj.fastClientPublicKey = message.fastClientPublicKey;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgAcceptOwnership>): MsgAcceptOwnership {
    return MsgAcceptOwnership.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgAcceptOwnership>): MsgAcceptOwnership {
    const message = createBaseMsgAcceptOwnership();
    message.newOwnerAddress = object.newOwnerAddress ?? "";
    message.fastClientPublicKey = object.fastClientPublicKey ?? "";
    return message;
  },
};

function createBaseMsgAcceptOwnershipResponse(): MsgAcceptOwnershipResponse {
  return {};
}

export const MsgAcceptOwnershipResponse = {
  encode(_: MsgAcceptOwnershipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAcceptOwnershipResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAcceptOwnershipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAcceptOwnershipResponse {
    return {};
  },

  toJSON(_: MsgAcceptOwnershipResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAcceptOwnershipResponse>): MsgAcceptOwnershipResponse {
    return MsgAcceptOwnershipResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgAcceptOwnershipResponse>): MsgAcceptOwnershipResponse {
    const message = createBaseMsgAcceptOwnershipResponse();
    return message;
  },
};

function createBaseMsgCancelOwnershipTransfer(): MsgCancelOwnershipTransfer {
  return { ownerAddress: "", fastClientPublicKey: "" };
}

export const MsgCancelOwnershipTransfer = {
  encode(message: MsgCancelOwnershipTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }
    if (message.fastClientPublicKey !== "") {
      writer.uint32(18).string(message.fastClientPublicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelOwnershipTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelOwnershipTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fastClientPublicKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCancelOwnershipTransfer {
    return {
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      fastClientPublicKey: isSet(object.fastClientPublicKey) ? globalThis.String(object.fastClientPublicKey) : "",
    };
  },

  toJSON(message: MsgCancelOwnershipTransfer): unknown {
    const obj: any = {};
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.fastClientPublicKey !== "") {
      obj.fastClientPublicKey = message.fastClientPublicKey;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgCancelOwnershipTransfer>): MsgCancelOwnershipTransfer {
    return MsgCancelOwnershipTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgCancelOwnershipTransfer>): MsgCancelOwnershipTransfer {
    const message = createBaseMsgCancelOwnershipTransfer();
    message.ownerAddress = object.ownerAddress ?? "";
    message.fastClientPublicKey = object.fastClientPublicKey ?? "";
    return message;
  },
};

function createBaseMsgCancelOwnershipTransferResponse(): MsgCancelOwnershipTransferResponse {
  return {};
}

export const MsgCancelOwnershipTransferResponse = {
  encode(_: MsgCancelOwnershipTransferResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelOwnershipTransferResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelOwnershipTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCancelOwnershipTransferResponse {
    return {};
  },

  toJSON(_: MsgCancelOwnershipTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgCancelOwnershipTransferResponse>): MsgCancelOwnershipTransferResponse {
    return MsgCancelOwnershipTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgCancelOwnershipTransferResponse>): MsgCancelOwnershipTransferResponse {
    const message = createBaseMsgCancelOwnershipTransferResponse();
    return message;
  },
};

function createBaseMsgAddUser(): MsgAddUser {
  return { adminAddress: "", fastClientPublicKey: "", userId: "", initialCredits: "" };
}

export const MsgAddUser = {
  encode(message: MsgAddUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.adminAddress !== "") {
      writer.uint32(10).string(message.adminAddress);
    }
    if (message.fastClientPublicKey !== "") {
      writer.uint32(18).string(message.fastClientPublicKey);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.initialCredits !== "") {
      writer.uint32(34).string(message.initialCredits);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adminAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fastClientPublicKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.initialCredits = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddUser {
    return {
      adminAddress: isSet(object.adminAddress) ? globalThis.String(object.adminAddress) : "",
      fastClientPublicKey: isSet(object.fastClientPublicKey) ? globalThis.String(object.fastClientPublicKey) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      initialCredits: isSet(object.initialCredits) ? globalThis.String(object.initialCredits) : "",
    };
  },

  toJSON(message: MsgAddUser): unknown {
    const obj: any = {};
    if (message.adminAddress !== "") {
      obj.adminAddress = message.adminAddress;
    }
    if (message.fastClientPublicKey !== "") {
      obj.fastClientPublicKey = message.fastClientPublicKey;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.initialCredits !== "") {
      obj.initialCredits = message.initialCredits;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgAddUser>): MsgAddUser {
    return MsgAddUser.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgAddUser>): MsgAddUser {
    const message = createBaseMsgAddUser();
    message.adminAddress = object.adminAddress ?? "";
    message.fastClientPublicKey = object.fastClientPublicKey ?? "";
    message.userId = object.userId ?? "";
    message.initialCredits = object.initialCredits ?? "";
    return message;
  },
};

function createBaseMsgAddUserResponse(): MsgAddUserResponse {
  return {};
}

export const MsgAddUserResponse = {
  encode(_: MsgAddUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddUserResponse {
    return {};
  },

  toJSON(_: MsgAddUserResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAddUserResponse>): MsgAddUserResponse {
    return MsgAddUserResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgAddUserResponse>): MsgAddUserResponse {
    const message = createBaseMsgAddUserResponse();
    return message;
  },
};

function createBaseMsgRemoveUser(): MsgRemoveUser {
  return { adminAddress: "", fastClientPublicKey: "", userId: "" };
}

export const MsgRemoveUser = {
  encode(message: MsgRemoveUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.adminAddress !== "") {
      writer.uint32(10).string(message.adminAddress);
    }
    if (message.fastClientPublicKey !== "") {
      writer.uint32(18).string(message.fastClientPublicKey);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRemoveUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adminAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fastClientPublicKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveUser {
    return {
      adminAddress: isSet(object.adminAddress) ? globalThis.String(object.adminAddress) : "",
      fastClientPublicKey: isSet(object.fastClientPublicKey) ? globalThis.String(object.fastClientPublicKey) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: MsgRemoveUser): unknown {
    const obj: any = {};
    if (message.adminAddress !== "") {
      obj.adminAddress = message.adminAddress;
    }
    if (message.fastClientPublicKey !== "") {
      obj.fastClientPublicKey = message.fastClientPublicKey;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveUser>): MsgRemoveUser {
    return MsgRemoveUser.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRemoveUser>): MsgRemoveUser {
    const message = createBaseMsgRemoveUser();
    message.adminAddress = object.adminAddress ?? "";
    message.fastClientPublicKey = object.fastClientPublicKey ?? "";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseMsgRemoveUserResponse(): MsgRemoveUserResponse {
  return {};
}

export const MsgRemoveUserResponse = {
  encode(_: MsgRemoveUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRemoveUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveUserResponse {
    return {};
  },

  toJSON(_: MsgRemoveUserResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveUserResponse>): MsgRemoveUserResponse {
    return MsgRemoveUserResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRemoveUserResponse>): MsgRemoveUserResponse {
    const message = createBaseMsgRemoveUserResponse();
    return message;
  },
};

function createBaseMsgTopUpUser(): MsgTopUpUser {
  return { sender: "", fastClientPublicKey: "", userId: "", amount: "" };
}

export const MsgTopUpUser = {
  encode(message: MsgTopUpUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.fastClientPublicKey !== "") {
      writer.uint32(18).string(message.fastClientPublicKey);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTopUpUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTopUpUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fastClientPublicKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTopUpUser {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      fastClientPublicKey: isSet(object.fastClientPublicKey) ? globalThis.String(object.fastClientPublicKey) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: MsgTopUpUser): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.fastClientPublicKey !== "") {
      obj.fastClientPublicKey = message.fastClientPublicKey;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgTopUpUser>): MsgTopUpUser {
    return MsgTopUpUser.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgTopUpUser>): MsgTopUpUser {
    const message = createBaseMsgTopUpUser();
    message.sender = object.sender ?? "";
    message.fastClientPublicKey = object.fastClientPublicKey ?? "";
    message.userId = object.userId ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgTopUpUserResponse(): MsgTopUpUserResponse {
  return {};
}

export const MsgTopUpUserResponse = {
  encode(_: MsgTopUpUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTopUpUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTopUpUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTopUpUserResponse {
    return {};
  },

  toJSON(_: MsgTopUpUserResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTopUpUserResponse>): MsgTopUpUserResponse {
    return MsgTopUpUserResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgTopUpUserResponse>): MsgTopUpUserResponse {
    const message = createBaseMsgTopUpUserResponse();
    return message;
  },
};

function createBaseMsgSettleCredits(): MsgSettleCredits {
  return { adminAddress: "", fastClientPublicKey: "", settleType: 0, amount: "" };
}

export const MsgSettleCredits = {
  encode(message: MsgSettleCredits, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.adminAddress !== "") {
      writer.uint32(10).string(message.adminAddress);
    }
    if (message.fastClientPublicKey !== "") {
      writer.uint32(18).string(message.fastClientPublicKey);
    }
    if (message.settleType !== 0) {
      writer.uint32(24).int32(message.settleType);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSettleCredits {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSettleCredits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adminAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fastClientPublicKey = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.settleType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSettleCredits {
    return {
      adminAddress: isSet(object.adminAddress) ? globalThis.String(object.adminAddress) : "",
      fastClientPublicKey: isSet(object.fastClientPublicKey) ? globalThis.String(object.fastClientPublicKey) : "",
      settleType: isSet(object.settleType) ? settleTypeFromJSON(object.settleType) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: MsgSettleCredits): unknown {
    const obj: any = {};
    if (message.adminAddress !== "") {
      obj.adminAddress = message.adminAddress;
    }
    if (message.fastClientPublicKey !== "") {
      obj.fastClientPublicKey = message.fastClientPublicKey;
    }
    if (message.settleType !== 0) {
      obj.settleType = settleTypeToJSON(message.settleType);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSettleCredits>): MsgSettleCredits {
    return MsgSettleCredits.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSettleCredits>): MsgSettleCredits {
    const message = createBaseMsgSettleCredits();
    message.adminAddress = object.adminAddress ?? "";
    message.fastClientPublicKey = object.fastClientPublicKey ?? "";
    message.settleType = object.settleType ?? 0;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgSettleCreditsResponse(): MsgSettleCreditsResponse {
  return { amount: "" };
}

export const MsgSettleCreditsResponse = {
  encode(message: MsgSettleCreditsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSettleCreditsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSettleCreditsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSettleCreditsResponse {
    return { amount: isSet(object.amount) ? globalThis.String(object.amount) : "" };
  },

  toJSON(message: MsgSettleCreditsResponse): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSettleCreditsResponse>): MsgSettleCreditsResponse {
    return MsgSettleCreditsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSettleCreditsResponse>): MsgSettleCreditsResponse {
    const message = createBaseMsgSettleCreditsResponse();
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgExpireUserCredits(): MsgExpireUserCredits {
  return { adminAddress: "", fastClientPublicKey: "", userId: "", amount: "" };
}

export const MsgExpireUserCredits = {
  encode(message: MsgExpireUserCredits, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.adminAddress !== "") {
      writer.uint32(10).string(message.adminAddress);
    }
    if (message.fastClientPublicKey !== "") {
      writer.uint32(18).string(message.fastClientPublicKey);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgExpireUserCredits {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgExpireUserCredits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adminAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fastClientPublicKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgExpireUserCredits {
    return {
      adminAddress: isSet(object.adminAddress) ? globalThis.String(object.adminAddress) : "",
      fastClientPublicKey: isSet(object.fastClientPublicKey) ? globalThis.String(object.fastClientPublicKey) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: MsgExpireUserCredits): unknown {
    const obj: any = {};
    if (message.adminAddress !== "") {
      obj.adminAddress = message.adminAddress;
    }
    if (message.fastClientPublicKey !== "") {
      obj.fastClientPublicKey = message.fastClientPublicKey;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgExpireUserCredits>): MsgExpireUserCredits {
    return MsgExpireUserCredits.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgExpireUserCredits>): MsgExpireUserCredits {
    const message = createBaseMsgExpireUserCredits();
    message.adminAddress = object.adminAddress ?? "";
    message.fastClientPublicKey = object.fastClientPublicKey ?? "";
    message.userId = object.userId ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgExpireUserCreditsResponse(): MsgExpireUserCreditsResponse {
  return {};
}

export const MsgExpireUserCreditsResponse = {
  encode(_: MsgExpireUserCreditsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgExpireUserCreditsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgExpireUserCreditsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgExpireUserCreditsResponse {
    return {};
  },

  toJSON(_: MsgExpireUserCreditsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgExpireUserCreditsResponse>): MsgExpireUserCreditsResponse {
    return MsgExpireUserCreditsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgExpireUserCreditsResponse>): MsgExpireUserCreditsResponse {
    const message = createBaseMsgExpireUserCreditsResponse();
    return message;
  },
};

function createBaseMsgSubmitReports(): MsgSubmitReports {
  return { address: "", fastClientPublicKey: new Uint8Array(0), reports: [] };
}

export const MsgSubmitReports = {
  encode(message: MsgSubmitReports, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.fastClientPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.fastClientPublicKey);
    }
    for (const v of message.reports) {
      FastUserReport.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSubmitReports {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitReports();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fastClientPublicKey = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reports.push(FastUserReport.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitReports {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      fastClientPublicKey: isSet(object.fastClientPublicKey)
        ? bytesFromBase64(object.fastClientPublicKey)
        : new Uint8Array(0),
      reports: globalThis.Array.isArray(object?.reports)
        ? object.reports.map((e: any) => FastUserReport.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgSubmitReports): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.fastClientPublicKey.length !== 0) {
      obj.fastClientPublicKey = base64FromBytes(message.fastClientPublicKey);
    }
    if (message.reports?.length) {
      obj.reports = message.reports.map((e) => FastUserReport.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitReports>): MsgSubmitReports {
    return MsgSubmitReports.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitReports>): MsgSubmitReports {
    const message = createBaseMsgSubmitReports();
    message.address = object.address ?? "";
    message.fastClientPublicKey = object.fastClientPublicKey ?? new Uint8Array(0);
    message.reports = object.reports?.map((e) => FastUserReport.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgSubmitReportsResponse(): MsgSubmitReportsResponse {
  return {};
}

export const MsgSubmitReportsResponse = {
  encode(_: MsgSubmitReportsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSubmitReportsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitReportsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitReportsResponse {
    return {};
  },

  toJSON(_: MsgSubmitReportsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitReportsResponse>): MsgSubmitReportsResponse {
    return MsgSubmitReportsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSubmitReportsResponse>): MsgSubmitReportsResponse {
    const message = createBaseMsgSubmitReportsResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams = {
  encode(message: MsgUpdateParams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse = {
  encode(_: MsgUpdateParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

/** Msg service defines the fast tx gRPC methods. */
export interface Msg {
  /** Registers a new fast client entry in the registry. */
  RegisterFastClient(request: MsgRegisterFastClient): Promise<MsgRegisterFastClientResponse>;
  /** Edits an existing fast client. */
  EditFastClient(request: MsgEditFastClient): Promise<MsgEditFastClientResponse>;
  /** Transfers the ownership of a fast client. */
  TransferOwnership(request: MsgTransferOwnership): Promise<MsgTransferOwnershipResponse>;
  /** Accepts the ownership of a fast client. */
  AcceptOwnership(request: MsgAcceptOwnership): Promise<MsgAcceptOwnershipResponse>;
  /** Cancels the ownership transfer of a fast client. */
  CancelOwnershipTransfer(request: MsgCancelOwnershipTransfer): Promise<MsgCancelOwnershipTransferResponse>;
  /** Adds a user to a fast client. */
  AddUser(request: MsgAddUser): Promise<MsgAddUserResponse>;
  /** Removes a user from a fast client. */
  RemoveUser(request: MsgRemoveUser): Promise<MsgRemoveUserResponse>;
  /** Top up a user's credits. */
  TopUpUser(request: MsgTopUpUser): Promise<MsgTopUpUserResponse>;
  /** Expire a user's credits. */
  ExpireUserCredits(request: MsgExpireUserCredits): Promise<MsgExpireUserCreditsResponse>;
  /** Settle a fast client's credits. */
  SettleCredits(request: MsgSettleCredits): Promise<MsgSettleCreditsResponse>;
  /** Submits reports for a fast client. */
  SubmitReports(request: MsgSubmitReports): Promise<MsgSubmitReportsResponse>;
  /** Used to update the modules parameters through the authority. */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}

export const MsgServiceName = "sedachain.fast.v1.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.RegisterFastClient = this.RegisterFastClient.bind(this);
    this.EditFastClient = this.EditFastClient.bind(this);
    this.TransferOwnership = this.TransferOwnership.bind(this);
    this.AcceptOwnership = this.AcceptOwnership.bind(this);
    this.CancelOwnershipTransfer = this.CancelOwnershipTransfer.bind(this);
    this.AddUser = this.AddUser.bind(this);
    this.RemoveUser = this.RemoveUser.bind(this);
    this.TopUpUser = this.TopUpUser.bind(this);
    this.ExpireUserCredits = this.ExpireUserCredits.bind(this);
    this.SettleCredits = this.SettleCredits.bind(this);
    this.SubmitReports = this.SubmitReports.bind(this);
    this.UpdateParams = this.UpdateParams.bind(this);
  }
  RegisterFastClient(request: MsgRegisterFastClient): Promise<MsgRegisterFastClientResponse> {
    const data = MsgRegisterFastClient.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterFastClient", data);
    return promise.then((data) => MsgRegisterFastClientResponse.decode(_m0.Reader.create(data)));
  }

  EditFastClient(request: MsgEditFastClient): Promise<MsgEditFastClientResponse> {
    const data = MsgEditFastClient.encode(request).finish();
    const promise = this.rpc.request(this.service, "EditFastClient", data);
    return promise.then((data) => MsgEditFastClientResponse.decode(_m0.Reader.create(data)));
  }

  TransferOwnership(request: MsgTransferOwnership): Promise<MsgTransferOwnershipResponse> {
    const data = MsgTransferOwnership.encode(request).finish();
    const promise = this.rpc.request(this.service, "TransferOwnership", data);
    return promise.then((data) => MsgTransferOwnershipResponse.decode(_m0.Reader.create(data)));
  }

  AcceptOwnership(request: MsgAcceptOwnership): Promise<MsgAcceptOwnershipResponse> {
    const data = MsgAcceptOwnership.encode(request).finish();
    const promise = this.rpc.request(this.service, "AcceptOwnership", data);
    return promise.then((data) => MsgAcceptOwnershipResponse.decode(_m0.Reader.create(data)));
  }

  CancelOwnershipTransfer(request: MsgCancelOwnershipTransfer): Promise<MsgCancelOwnershipTransferResponse> {
    const data = MsgCancelOwnershipTransfer.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelOwnershipTransfer", data);
    return promise.then((data) => MsgCancelOwnershipTransferResponse.decode(_m0.Reader.create(data)));
  }

  AddUser(request: MsgAddUser): Promise<MsgAddUserResponse> {
    const data = MsgAddUser.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddUser", data);
    return promise.then((data) => MsgAddUserResponse.decode(_m0.Reader.create(data)));
  }

  RemoveUser(request: MsgRemoveUser): Promise<MsgRemoveUserResponse> {
    const data = MsgRemoveUser.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveUser", data);
    return promise.then((data) => MsgRemoveUserResponse.decode(_m0.Reader.create(data)));
  }

  TopUpUser(request: MsgTopUpUser): Promise<MsgTopUpUserResponse> {
    const data = MsgTopUpUser.encode(request).finish();
    const promise = this.rpc.request(this.service, "TopUpUser", data);
    return promise.then((data) => MsgTopUpUserResponse.decode(_m0.Reader.create(data)));
  }

  ExpireUserCredits(request: MsgExpireUserCredits): Promise<MsgExpireUserCreditsResponse> {
    const data = MsgExpireUserCredits.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExpireUserCredits", data);
    return promise.then((data) => MsgExpireUserCreditsResponse.decode(_m0.Reader.create(data)));
  }

  SettleCredits(request: MsgSettleCredits): Promise<MsgSettleCreditsResponse> {
    const data = MsgSettleCredits.encode(request).finish();
    const promise = this.rpc.request(this.service, "SettleCredits", data);
    return promise.then((data) => MsgSettleCreditsResponse.decode(_m0.Reader.create(data)));
  }

  SubmitReports(request: MsgSubmitReports): Promise<MsgSubmitReportsResponse> {
    const data = MsgSubmitReports.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitReports", data);
    return promise.then((data) => MsgSubmitReportsResponse.decode(_m0.Reader.create(data)));
  }

  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
